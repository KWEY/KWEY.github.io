<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>雪人 - 笔记</title><meta name="keywords" content="sql  python node  video web html css javascript"><meta name="author" content="雪人"><meta name="copyright" content="雪人"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="雪人的笔记">
<meta property="og:type" content="website">
<meta property="og:title" content="雪人">
<meta property="og:url" content="https://www.webq.top/page/3/index.html">
<meta property="og:site_name" content="雪人">
<meta property="og:description" content="雪人的笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.webq.top/img/face.jpg">
<meta property="article:author" content="雪人">
<meta property="article:tag" content="sql  python node  video web html css javascript">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.webq.top/img/face.jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://www.webq.top/page/3/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="manifest" href="/pwa/manifest.json"/><link rel="apple-touch-icon" sizes="180x180" href="/pwa/favicon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/pwa/favicon.png"/><link rel="icon" type="image/png" sizes="16x16" href="/pwa/favicon.png"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '5.2.0',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  ClickShowText: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: false,
  isHome: true,
  isHighlightShrink: false,
  isSidebar: false,
  postUpdate: '2021-07-11 20:14:53'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {
  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }

  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }
})()</script><meta name="generator" content="Hexo 5.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/face.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">153</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">40</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">12</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 工具集</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/follow/"><i class="fa-fw fas fa-star"></i><span> 收藏夹</span></a></li><li><a class="site-page" href="/audio/"><i class="fa-fw fas fa-music"></i><span> audio_context</span></a></li><li><a class="site-page" href="/piano/"><i class="fa-fw fas fa-music"></i><span> 在线Piano</span></a></li><li><a class="site-page" href="/hy/"><i class="fa-fw fas fa-video"></i><span> Canvas绘图</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 文档库</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/2020/11/15/doc/ci/"><i class="fa-fw far fa-circle"></i><span> CI</span></a></li><li><a class="site-page" href="/2020/11/15/doc/h264/"><i class="fa-fw far fa-video"></i><span> h264</span></a></li><li><a class="site-page" href="/2020/11/15/doc/f4v/"><i class="fa-fw far fa-video"></i><span> f4v</span></a></li><li><a class="site-page" href="/2020/11/15/doc/mask/"><i class="fa-fw far fa-mask"></i><span> mask</span></a></li><li><a class="site-page" href="/2020/11/15/doc/dj/"><i class="fa-fw far fa-python"></i><span> Django</span></a></li><li><a class="site-page" href="/2020/11/15/doc/mse/"><i class="fa-fw far fa-buffer"></i><span> MSE</span></a></li></ul></div></div></div></div><div id="body-wrap"><header class="full_page" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">雪人</a></span><span id="menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 工具集</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/follow/"><i class="fa-fw fas fa-star"></i><span> 收藏夹</span></a></li><li><a class="site-page" href="/audio/"><i class="fa-fw fas fa-music"></i><span> audio_context</span></a></li><li><a class="site-page" href="/piano/"><i class="fa-fw fas fa-music"></i><span> 在线Piano</span></a></li><li><a class="site-page" href="/hy/"><i class="fa-fw fas fa-video"></i><span> Canvas绘图</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 文档库</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/2020/11/15/doc/ci/"><i class="fa-fw far fa-circle"></i><span> CI</span></a></li><li><a class="site-page" href="/2020/11/15/doc/h264/"><i class="fa-fw far fa-video"></i><span> h264</span></a></li><li><a class="site-page" href="/2020/11/15/doc/f4v/"><i class="fa-fw far fa-video"></i><span> f4v</span></a></li><li><a class="site-page" href="/2020/11/15/doc/mask/"><i class="fa-fw far fa-mask"></i><span> mask</span></a></li><li><a class="site-page" href="/2020/11/15/doc/dj/"><i class="fa-fw far fa-python"></i><span> Django</span></a></li><li><a class="site-page" href="/2020/11/15/doc/mse/"><i class="fa-fw far fa-buffer"></i><span> MSE</span></a></li></ul></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav></header><main class="layout_page" id="content-inner"><div class="recent-posts" id="recent-posts"><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2020/11/14/linux/jdk/" title="Linux安装jdk的三种方法">     <img class="post_bg" src="/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux安装jdk的三种方法"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/11/14/linux/jdk/" title="Linux安装jdk的三种方法">Linux安装jdk的三种方法</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-11-14T08:10:34.252Z" title="发表于 2020-11-14 16:10:34">2020-11-14</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox article-meta__icon"></i><a class="article-meta__categories" href="/categories/Linux/">Linux</a></span></div><div class="content">环境：
Linux版本：CentOS 6.5
JDK版本：JDK 1.7
方法：方法一：手动解压JDK的压缩包，然后设置环境变量方法二：用yum安装JDK方法三：用rpm安装JDK
方法一：手动解压JDK的压缩包，然后设置环境变量
`1.在/usr/目录下创建java目录 
[root@localhost ~]# mkdir/usr/java[root@localhost ~]# cd /usr/java
2.下载，然后解压 ``` bash[root@localhost java]# curl -O http://download.oracle.com/otn-pub/java/jdk/7u79-b15/jdk-7u79-linux-x64.tar.gz[root@localhost java]# tar -zxvf jdk-7u79-linux-x64.tar.gz
&#96;3.设置环境变量&#96;&#96;&#96; bash[root@localhost java]# vi &#x2F;etc&#x2F;profile
添加如下内容：
#set java environme ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2020/11/14/linux/jenkins/" title="CentOS7下yum安装Jenkins">     <img class="post_bg" src="/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CentOS7下yum安装Jenkins"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/11/14/linux/jenkins/" title="CentOS7下yum安装Jenkins">CentOS7下yum安装Jenkins</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-11-14T08:10:34.252Z" title="发表于 2020-11-14 16:10:34">2020-11-14</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox article-meta__icon"></i><a class="article-meta__categories" href="/categories/Linux/">Linux</a></span></div><div class="content">准备条件：安装Java（CentOS下安装Java1.8）1、Yum安装yum源导入
#添加Yum源sudo wget -O /etc/yum.repos.d/jenkins.repo https://pkg.jenkins.io/redhat-stable/jenkins.repo#导入密钥sudo rpm --import https://pkg.jenkins.io/redhat-stable/jenkins.io.key

安装
sudo yum install -y jenkins
2、开放端口Jenkins站点的默认监听端口是8080(防火墙安装看这)
sudo firewall-cmd --add-port=8080/tcp --permanentsudo firewall-cmd --reload

3、安装完成后启动Jenkins：
检查Jenkins服务状态sudo systemctl status jenkins
设置为开机自启动sudo systemctl enable jenkins
启动Jenkins服务sudo systemctl start jenkin ...</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2020/11/14/linux/kcptun/" title="使用kcptun加速shadowsocks">     <img class="post_bg" src="/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="使用kcptun加速shadowsocks"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/11/14/linux/kcptun/" title="使用kcptun加速shadowsocks">使用kcptun加速shadowsocks</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-11-14T08:10:34.252Z" title="发表于 2020-11-14 16:10:34">2020-11-14</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox article-meta__icon"></i><a class="article-meta__categories" href="/categories/Linux/">Linux</a></span></div><div class="content">
Kcptun 是一个非常简单和快速的，基于 KCP 协议的 UDP 隧道，它可以将 TCP 流转换为 KCP+UDP 流。而 KCP 是一个快速可靠协议，能以比 TCP 浪费100%-200%的带宽的代价（理想状态下），换取平均延迟降低 30%-40%，且最大延迟降低三倍的传输效果。

网络诊断地址
工作原理：
服务端安装 KCPTunwget --no-check-certificate https://github.com/kuoruan/shell-scripts/raw/master/kcptun/kcptun.sh &amp;&amp; chmod +x ./kcptun.sh &amp;&amp; ./kcptun.sh

接下来会依次提醒设置以下参数（这里是最终的结果

1、端口：默认29900，即为KCPTUN与其客户端连接使用的端口，默认即可。
2、要加速的地址：默认127.0.0.1。
3、要加速的端口：设置为你的SS/SSR使用的端口。
4、密码：自己设置，用于KCPTUN客户端连接使用，不要使用默认密码。
5、加密方式选择：较强的加密方式会影响网速，建议默认a ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2020/11/14/linux/crontab-mongo/" title="Linux定时任务 + mongodb自动备份">     <img class="post_bg" src="/img/default2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux定时任务 + mongodb自动备份"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/11/14/linux/crontab-mongo/" title="Linux定时任务 + mongodb自动备份">Linux定时任务 + mongodb自动备份</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-11-14T08:10:34.251Z" title="发表于 2020-11-14 16:10:34">2020-11-14</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox article-meta__icon"></i><a class="article-meta__categories" href="/categories/Linux/">Linux</a></span></div><div class="content">
mongodump -d k-blog -c articles -o ./

原文地址
Linux 自动定时备份 MongoDB
mongodb自动整库备份脚本#!/bin/shDB_HOST=&quot;127.0.0.1&quot;DB_NAME=&quot;node_user&quot;OUT_DIR=&quot;/data/backup/mongod_bak/mongod_bak_now&quot; #临时备份目录TAR_DIR=&quot;/data/backup/mongod_bak/mongod_bak_list&quot; #备份存放路径DATE=$(date +%Y_%m_%d) #获取当前系统时间echo &quot;-----当前时间为$DATE-----&quot;DAYS=7 #DAYS=7代表删除7天前的备份，即只保留最近7天的备份TAR_BAK=&quot;mongod_bak_$DATE.tar.gz&quot; #最终保存的数据库备份文件名cd $OUT_DIRecho &quot;-----删除原有备份文件-----&quot;find $OUT_ ...</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2020/11/14/linux/crontab/" title="crontab 定时任务">     <img class="post_bg" src="/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="crontab 定时任务"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/11/14/linux/crontab/" title="crontab 定时任务">crontab 定时任务</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-11-14T08:10:34.251Z" title="发表于 2020-11-14 16:10:34">2020-11-14</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox article-meta__icon"></i><a class="article-meta__categories" href="/categories/Linux/">Linux</a></span></div><div class="content">
通过crontab 命令，我们可以在固定的间隔时间执行指定的系统指令或 shell script脚本。时间间隔的单位可以是分钟、小时、日、月、周及以上的任意组合

crontab 定时任务每天一个linux命令（50）：crontab命令
Linux 下执行定时任务 crontab 命令详解
linux命令
Centos7:利用crontab定时执行任务
19、crontab 定时任务19.1. 命令格式crontab [-u user] file crontab [-u user] [ -e | -l | -r ]
19.2. 命令参数
-u user：用来设定某个用户的crontab服务；
file：file是命令文件的名字,表示将file做为crontab的任务列表文件并载入crontab。如果在命令行中没有指定这个文件，crontab命令将接受标准输入（键盘）上键入的命令，并将它们载入crontab。
-e：编辑某个用户的crontab文件内容。如果不指定用户，则表示编辑当前用户的crontab文件。
-l：显示某个用户的crontab文件内容，如果不指定用户，则表示显示当前 ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2020/11/14/linux/google-bbr/" title="SSR开启Google的BBR内核脚本加速TCP">     <img class="post_bg" src="/img/default2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SSR开启Google的BBR内核脚本加速TCP"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/11/14/linux/google-bbr/" title="SSR开启Google的BBR内核脚本加速TCP">SSR开启Google的BBR内核脚本加速TCP</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-11-14T08:10:34.251Z" title="发表于 2020-11-14 16:10:34">2020-11-14</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox article-meta__icon"></i><a class="article-meta__categories" href="/categories/Linux/">Linux</a></span></div><div class="content">
Google 开源了其 TCP BBR 拥塞控制算法，并提交到了 Linux 内核，从 4.9 开始，Linux 内核已经用上了该算法。根据以往的传统，Google 总是先在自家的生产环境上线运用后，才会将代码开源，此次也不例外。

BBR 这个特性其实是在 Linux 内核 4.9 才计划加入的。所以，要开启BBR，需要内核版本在Linux kernel 4.9以上，根据实地测试，在部署了最新版内核并开启了 TCP BBR 的机器上，网速甚至可以提升好几个数量级。下面纪录一下如何升级Linux内核，并且开启BBR：
下载bbr 安装脚本：
wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh &amp;&amp; chmod +x bbr.sh &amp;&amp; ./bbr.sh

安装成功后重启服务器
shutdown -r now

查看内核版本，如果返回值含有4.13或以上版本, 就表示安装成功了。
uname -r

sysctl net.ipv4.tcp_ava ...</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2020/11/14/linux/firewalld/" title="centos7安装防火墙firewalld">     <img class="post_bg" src="/img/default3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="centos7安装防火墙firewalld"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/11/14/linux/firewalld/" title="centos7安装防火墙firewalld">centos7安装防火墙firewalld</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-11-14T08:10:34.251Z" title="发表于 2020-11-14 16:10:34">2020-11-14</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox article-meta__icon"></i><a class="article-meta__categories" href="/categories/Linux/">Linux</a></span></div><div class="content">默认情况下CentOS 7可能已经安装了firewalld服务，若确实没有安装直接使用yum命令安装即可：
先来安装# yum install -y firewalld
常用命令安装完成后firewalld并没有运行，有必要先来熟悉下基本的命令：
#查看运行状态firewall-cmd --state#启动firewallsystemctl start firewalld#设置开机自启systemctl enable firewalld#删除开机自启systemctl disable firewalld#停止firewallsystemctl stop firewalld

注：elasticsearch需要开放9200,9300两个端口
# firewall-cmd --add-port=9200/tcp --permanent  #永久开放9200端口# firewall-cmd --add-port=9300/tcp --permanent  #永久开放9300端口# firewall-cmd --reload  #重新加载# firewall-cmd --list-all #查 ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2020/11/14/linux/centos-cmd/" title="centos7 常用命令【systemctl替换service】">     <img class="post_bg" src="/img/default2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="centos7 常用命令【systemctl替换service】"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/11/14/linux/centos-cmd/" title="centos7 常用命令【systemctl替换service】">centos7 常用命令【systemctl替换service】</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-11-14T08:10:34.250Z" title="发表于 2020-11-14 16:10:34">2020-11-14</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox article-meta__icon"></i><a class="article-meta__categories" href="/categories/Linux/">Linux</a></span></div><div class="content">centos7 上面启动服务以及关闭服务已经不是以前的service stop/start xxxx了
而是systemctl命令，不过用service他会有一个提醒你用systemctl”,

“content”: ‘ ‘ 看所有网卡IP地址——ip addr
启动防火墙——systemctl start firewalld.service
停止防火墙——systemctl stop firewalld.service
查看firewalld防火墙状态——firewall-cmd –state
禁止防火墙开机启动——systemctl disable firewalld.service
列出正在运行的服务状态——systemctl
启动一个服务—— systemctl start postfix.service
关闭一个服务—— systemctl stop postfix.servic
重启一个服务：—— systemctl restart postfix.service
显示一个服务的状态—— systemctl status postfix.service
在开机时启用一个服务 ...</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2020/11/14/linux/centos-node/" title="Centos7 安装nvm、node">     <img class="post_bg" src="/img/default3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Centos7 安装nvm、node"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/11/14/linux/centos-node/" title="Centos7 安装nvm、node">Centos7 安装nvm、node</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-11-14T08:10:34.250Z" title="发表于 2020-11-14 16:10:34">2020-11-14</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox article-meta__icon"></i><a class="article-meta__categories" href="/categories/Linux/">Linux</a></span></div><div class="content">首先：安装nvm
下载命令curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.34.0/install.sh | bash
或者
wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.34.0/install.sh | bash

下载完成后加入系统环境source   ~/.bashrc

查看 NVM 版本list
nvm list-romote



4、安装需要的node版本
nvm install  v11.9.0
查看当前机器已安装版本号
nvm list
切换node版本
nvm use v11.9.0
7、设置默认的node版本
nvm alias default v11.9.0

n是Node的一个模块，作者是TJ Holowaychuk（Express框架作者）
n与nvm的区别

n是 npm 的一个全局模块，安装n之前需要先安装node。nvm是一个独立软件包。

在安装的时候，n会先将指定版本的 node 存储下来，然后将 ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2020/11/14/linux/crontab-1/" title="centos7 常用命令【systemctl替换service】">     <img class="post_bg" src="/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="centos7 常用命令【systemctl替换service】"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/11/14/linux/crontab-1/" title="centos7 常用命令【systemctl替换service】">centos7 常用命令【systemctl替换service】</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-11-14T08:10:34.250Z" title="发表于 2020-11-14 16:10:34">2020-11-14</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox article-meta__icon"></i><a class="article-meta__categories" href="/categories/Linux/">Linux</a></span></div><div class="content">
service crond status

1、先手动执行定时任务以此来判断脚本是否有问题。
2、确认服务器是否开启定时任务计划服务
命令：
service crond statusservice crond start

3、查看crontab执行记录
如果出现了crontab定时任务不执行的情况，首先需要定位问题，那么就需要通过日志来确定问题所在。
crontab的日志位置一般位于/var/log/cron，利用下面的语句即可查看日志。
tail -f /var/log/cron
上面的/var/log/cron只会记录是否执行了某些计划的脚本，但是具体执行是否正确以及脚本执行过程中的一些信息linux
会通过邮件形式发送到给该用户。对于root用户该邮件记录位于/var/spool/mail/root，通过以下命令可以查看最近的crontab执行情况。
tail -f /var/spool/mail/root
mail邮件一般只会记录脚本执行成功与否，如果执行失败，无法给出进一步的错误信息，这时需要我们将语句执行的错误信息
重定向至文件中，这样可以很方便的查看错误信息
</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2020/11/14/js/xss-csrf/" title="XSS和CSRF">     <img class="post_bg" src="/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="XSS和CSRF"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/11/14/js/xss-csrf/" title="XSS和CSRF">XSS和CSRF</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-11-14T08:10:34.250Z" title="发表于 2020-11-14 16:10:34">2020-11-14</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox article-meta__icon"></i><a class="article-meta__categories" href="/categories/Javascript/">Javascript</a></span></div><div class="content">
跨站脚本攻击(Cross Site Scripting)、跨站请求伪造(Cross Site Request Forgery)

XSS，(cross site scripting),跨站脚本注入，指攻击者利用一些技巧向页面注入脚本代码并让其执行，从而达成攻击效果。
XSS原理攻击者利用页面输入和输出的功能，在输入时使用闭标签再加脚本代码等技巧，当服务器输出这些输入信息到页面时，就会插入并执行脚本代码。解决方法是可以在服务端对客户端的输入进行过滤或转义。注意：这里不一定只用script标签，还可以用img等其他标签，或者用onclick等事件方法达到执行脚本代码。简单例子如下：
//Web 请求如下所示：GET http://www.somesite.com/page.asppageid=10&amp;lang=en&amp;title=Section%20Title//在发出请求后，服务器返回的 HTML 内容包括：// Section Title// 攻击者可以通过摆脱 //  标记来注入代码：// http://www.somesite.com/page.asp?pageid= ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2020/11/14/js/video-demuxing-muxing/" title="new 命令">     <img class="post_bg" src="/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="new 命令"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/11/14/js/video-demuxing-muxing/" title="new 命令">new 命令</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-11-14T08:10:34.249Z" title="发表于 2020-11-14 16:10:34">2020-11-14</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox article-meta__icon"></i><a class="article-meta__categories" href="/categories/web/">web</a></span></div><div class="content">
Mux 是 Multiplex 的缩写，意为“多路传输”，其实就是“混流”、“封装”的意思，与“合成”的意思相似就是指把视频素材和音频素材封装到一个单独的文件中。

muxing 是在mux 后面加了 -ing 构成的动名词形式。Demux是在 mux 前面加了个表示否定的 De- 前缀，意思是进行与 muxing 相反的“分解复用”操作，也就是我们平时说的“分离”一个文件中的视频部分或是音频部分。同样，也可以在 demux 后面加 -ing 构成动名词 demuxing。意义：通过 muxing（混流），可以将视频流、音频流甚至是字幕流捆绑到一个单独的文件中，作为一个信号进行传输，等传输完毕，就可以通过 demuxing（分离） 将里面的视频、音频或字幕分解出来各自进行解码和播放。要点：在 muxing 与 demuxing 的整个过程，都不对原来的视频、音频或字幕重新编码。混流（封装、打包）后的文件，可以通过分离（分解、解包）操作，获得与原始素材一模一样的独立的视频、音频和字幕文件。
视频的分离与合成，编码和解码
对媒体流的处理分为两种：“编码（encoding）”和“解码（de ...</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2020/11/14/js/web-worker/" title="Web Worker">     <img class="post_bg" src="/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Web Worker"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/11/14/js/web-worker/" title="Web Worker">Web Worker</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-11-14T08:10:34.249Z" title="发表于 2020-11-14 16:10:34">2020-11-14</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox article-meta__icon"></i><a class="article-meta__categories" href="/categories/Javascript/">Javascript</a></span></div><div class="content">
为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给Worker 线程

Web Worker 有以下几个使用注意点。

同源限制
  分配给 Worker 线程运行的脚本文件，必须与主线程的脚本文件同源。

DOM 限制
  Worker 线程所在的全局对象，与主线程不一样，无法读取主线程所在网页的 DOM 对象，也无法使用document、window、parent这些对象。但是，Worker 线程可以navigator对象和location对象。

通信联系
  Worker 线程和主线程不在同一个上下文环境，它们不能直接通信，必须通过消息完成。

脚本限制
  Worker 线程不能执行alert()方法和confirm()方法，但可以使用 XMLHttpRequest 对象发出 AJAX 请求。

文件限制
  Worker 线程无法读取本地文件，即不能打开本机的文件系统（file://），它所加载的脚本，必须来自网络。


主线程主线程采用new命令，调用Worker()构造函数，新建一个 Worker 线程。
var worke ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2020/11/14/js/web-err/" title="前端异常监控解决方案">     <img class="post_bg" src="/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="前端异常监控解决方案"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/11/14/js/web-err/" title="前端异常监控解决方案">前端异常监控解决方案</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-11-14T08:10:34.249Z" title="发表于 2020-11-14 16:10:34">2020-11-14</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox article-meta__icon"></i><a class="article-meta__categories" href="/categories/Javascript/">Javascript</a></span></div><div class="content">
前端监控包括行为监控、异常监控、性能监控等,一个用户在操作应用过程中如果出现异常，有可能是前端引起，也有可能是后端引起，需要有一个机制，将前后端串联起来，使监控本身统一于监控系统。

原文地址
一个监控系统，大致可以分为四个阶段:
采集阶段：收集异常日志，先在本地做一定的处理，采取一定的方案上报到服务器。
存储阶段：后端接收前端上报的异常日志，经过一定处理，按照一定的存储方案存储。
分析阶段：分为机器自动分析和人工分析。机器自动分析，通过预设的条件和算法，对存储的日志信息进行统计和筛选，发现问题，触发报警。人工分析，通过提供一个可视化的数据面板，让系统用户可以看到具体的日志数据，根据信息，发现异常问题根源。
报警阶段：分为告警和预警。告警按照一定的级别自动报警，通过设定的渠道，按照一定的触发规则进行。预警则在异常发生前，提前预判，给出警告。
一、前端异常1.1 前端异常分类a. 出错界面呈现的内容与用户预期的内容不符，例如点击进入非目标界面，数据不准确，出现的错误提示不可理解，界面错位，提交后跳转到错误界面等情况。这类异常出现时，虽然产品本身功能还能正常使用，但用户无法达成自己目标。 ...</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2020/11/14/js/sort/" title="各种排序实现">     <img class="post_bg" src="/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="各种排序实现"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/11/14/js/sort/" title="各种排序实现">各种排序实现</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-11-14T08:10:34.248Z" title="发表于 2020-11-14 16:10:34">2020-11-14</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox article-meta__icon"></i><a class="article-meta__categories" href="/categories/web/">web</a></span></div><div class="content">
十大经典排序算法总结

 详细图文解析 看这
一、冒泡demo:// 冒泡排序: 比较两个相邻的项，如果第一个大于第二个则交换他们的位置,元素项向上移动至正确的顺序，//就好像气泡往上冒一样function bubbleSort(arr) &#123;    let len = arr.length;    for (let i = 0; i &lt; len; i++) &#123;        for (let j = 0; j &lt; len - 1 - i; j++) &#123;            if (arr[j] &gt; arr[j+1]) &#123;        //相邻元素两两对比                [arr[j + 1], arr[j]] = [arr[j], arr[j + 1]];            &#125;        &#125;    &#125;    return arr;&#125;// 1) 首先，在数组中选择一个中间项作为主元// 2) 创建两个指针，左边的指向数组第一个项，右边的指向最后一个项，移动左指针 ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2020/11/14/js/stack/" title="JavaScipt中栈的实现">     <img class="post_bg" src="/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JavaScipt中栈的实现"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/11/14/js/stack/" title="JavaScipt中栈的实现">JavaScipt中栈的实现</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-11-14T08:10:34.248Z" title="发表于 2020-11-14 16:10:34">2020-11-14</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox article-meta__icon"></i><a class="article-meta__categories" href="/categories/web/">web</a></span></div><div class="content">
栈是一种遵从后进先出原则(LIFO,全称为Last In First Out)的有序集合。栈顶永远是最新的元素。

栈需要有如下的方法:

push(element(s)): 添加几个元素到栈顶
pop(): 移除并返回栈顶元素
peek(): 返回栈顶元素
isAmpty: 检查栈是否为空，为空则返回true
clear: 移除栈中所有元素
size: 返回栈中元素个数。
print: 以字符串显示栈中所有内容

/*** 栈的构造函数*/function Stack() &#123;    /**    * 用数组来模拟栈    * @type &#123;Array&#125;    */    var items = [];    /**    * 将元素送入栈，放置于数组的最后一位    * @param  &#123;Any&#125; element 接受的元素，不限制类型    */    this.push = function(element) &#123;        items.push(element);    &#125;;    /**    * 弹出 ...</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2020/11/14/js/textContent/" title="Node.textContent">     <img class="post_bg" src="/img/default3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Node.textContent"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/11/14/js/textContent/" title="Node.textContent">Node.textContent</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-11-14T08:10:34.248Z" title="发表于 2020-11-14 16:10:34">2020-11-14</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox article-meta__icon"></i><a class="article-meta__categories" href="/categories/web/">web</a></span></div><div class="content">
Node.textContent 属性表示一个节点及其后代的文本内容。

1、如果 element 是 Document，DocumentType 或者 Notation 类型节点，则 textContent 返回 null。如果你要获取整个文档的文本以及CDATA数据，可以使用document.documentElement.textContent。2、如果节点是个CDATA片段，注释，ProcessingInstruction节点或一个文本节点，textContent 返回节点内部的文本内容（即 nodeValue）。3、对于其他节点类型，textContent 将所有子节点的 textContent 合并后返回，除了注释、ProcessingInstruction节点。如果该节点没有子节点的话，返回一个空字符串。4、在节点上设置 textContent 属性的话，会删除它的所有子节点，并替换为一个具有给定值的文本节点。

与innerText的区别IE引入了node.innerText。意图类似，但有以下区别：
1、textContent 会获取所有元素的内容，包括script ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2020/11/14/js/tostring/" title="toString方法和valueOf方法以及Symbol.toPrimitive">     <img class="post_bg" src="/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="toString方法和valueOf方法以及Symbol.toPrimitive"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/11/14/js/tostring/" title="toString方法和valueOf方法以及Symbol.toPrimitive">toString方法和valueOf方法以及Symbol.toPrimitive</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-11-14T08:10:34.248Z" title="发表于 2020-11-14 16:10:34">2020-11-14</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox article-meta__icon"></i><a class="article-meta__categories" href="/categories/web/">web</a></span></div><div class="content">
每个对象都有一个toString()方法和valueOf方法，其中toString()方法返回一个表示该对象的字符串，valueOf方法返回该对象的原始值。

对于值类型数据(又叫基本类型)场景下，toString及valueOf方法的使用toString方法对于值类型数据使用而言，其效果相当于类型转换，将原类型转为字符串。
valueOf方法对于值类型数据使用而言，其效果将相当于返回原数据。 
复合对象类型数据使用toString及valueOf方法var test = &#123;     i: 10,     toString: function() &#123;         console.log(&#x27;toString&#x27;);         return this.i;     &#125;,     valueOf: function() &#123;         console.log(&#x27;valueOf&#x27;);         return this.i;     &#125; &#125; alert(test);// 10  ...</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2020/11/14/js/ts-3.7/" title="TypeScript 3.7、TypeScript 3.8 Beta">     <img class="post_bg" src="/img/js.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="TypeScript 3.7、TypeScript 3.8 Beta"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/11/14/js/ts-3.7/" title="TypeScript 3.7、TypeScript 3.8 Beta">TypeScript 3.7、TypeScript 3.8 Beta</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-11-14T08:10:34.248Z" title="发表于 2020-11-14 16:10:34">2020-11-14</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox article-meta__icon"></i><a class="article-meta__categories" href="/categories/Javascript/">Javascript</a></span></div><div class="content">原文链接： TypeScript 3.7
翻译地址
TypeScript 3.8 Beta
1、可选链## 2、空值联合&lt;a href=&quot;https://www.webq.top/article/926&quot; target=&quot;_blank&quot; style=&quot;font-size: 14px;&quot;&gt;参照上文：es2020&lt;/a&gt;
3、断言函数      它们是一些特殊函数的集合。当一些非预期的事情发生的时候它们将抛出 error。它们被称为断言函数
function isString(val: any): val is string &#123;    return typeof val === &quot;string&quot;;&#125;function yell(str: any) &#123;    if (isString(str)) &#123;        return str.toUppercase();    &#125;    throw &quot;Oops!&quot;;&#125;
 ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2020/11/14/js/ts-dts/" title="TS声明文件">     <img class="post_bg" src="/img/default3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="TS声明文件"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/11/14/js/ts-dts/" title="TS声明文件">TS声明文件</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-11-14T08:10:34.248Z" title="发表于 2020-11-14 16:10:34">2020-11-14</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox article-meta__icon"></i><a class="article-meta__categories" href="/categories/web/">web</a></span></div><div class="content">
当使用外部JavaScript库或新的宿主API时，需要一个自定义声明文件（.d.ts）

原文地址
流程最好从程序库的文档而不是代码开始写.d.ts文件。 这样保证不会被具体实现所干扰，而且相比于JS代码更易读。 下面的例子会假设你正在参照文档写声明文件。
命名空间当定义接口（例如：“options”对象），你会选择是否将这些类型放进命名空间里。 这主要是靠主观判断 – 如果使用的人主要是用这些类型来声明变量和参数，并且类型命名不会引起命名冲突，则放在全局命名空间里更好。 如果类型不是被直接使用，或者没法起一个唯一的名字的话，就使用命名空间来避免与其它类型发生冲突。
回调函数许多JavaScript库接收一个函数做为参数，之后传入已知的参数来调用它。 当用这些类型为函数签名的时候，不要把这些参数标记成可选参数。 正确的思考方式是“(调用者)会提供什么样的参数？”，不是“(函数)会使用到什么样的参数？”。
 TypeScript 0.9.7+不会强制这种可选参数的使用，参数可选的双向协变可以被外部的linter强制执行。
扩展与声明合并写声明文件的时候，要记住TypeScript扩展 ...</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2020/11/14/js/parseInt/" title="parseInt() 函数">     <img class="post_bg" src="/img/default3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="parseInt() 函数"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/11/14/js/parseInt/" title="parseInt() 函数">parseInt() 函数</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-11-14T08:10:34.247Z" title="发表于 2020-11-14 16:10:34">2020-11-14</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox article-meta__icon"></i><a class="article-meta__categories" href="/categories/web/">web</a></span></div><div class="content">
parseInt(string, radix)函数可解析一个字符串，并返回一个整数。




param
详情



string
必需。要被解析的字符串。


radix
可选。表示要解析的数字的基数。该值介于 2 ~ 36 之间。 如果省略该参数或其值为 0，则数字将以 10 为基础来解析。如果它以 “0x” 或 “0X” 开头，将以 16 为基数。如果该参数小于 2 或者大于 36，则 parseInt() 将返回 NaN。


返回值返回解析后的数字。当参数 radix 的值为 0，或没有设置该参数时，parseInt() 会根据 string 来判断数字的基数。举例，如果 string 以 “0x” 开头，parseInt() 会把 string 的其余部分解析为十六进制的整数。如果 string 以 0 开头，那么 ECMAScript v3 允许 parseInt() 的一个实现把其后的字符解析为八进制或十六进制的数字。如果 string 以 1 ~ 9 的数字开头，parseInt() 将把它解析为十进制的整数。

注意


只有字符串中的第一个数字会被返回。

开头 ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2020/11/14/js/queue/" title="JavaScipt中队列的实现">     <img class="post_bg" src="/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JavaScipt中队列的实现"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/11/14/js/queue/" title="JavaScipt中队列的实现">JavaScipt中队列的实现</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-11-14T08:10:34.247Z" title="发表于 2020-11-14 16:10:34">2020-11-14</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox article-meta__icon"></i><a class="article-meta__categories" href="/categories/web/">web</a></span></div><div class="content">
队列与栈是很相像的数据结构，不同之处在于队列是是先进先出(FIFO:First In First Out)的。


队列需要有如下的方法:
enqueue(element(s)): 向队列尾部添加几个项
dequeue(): 移除队列的第一项(也就是排在最前面的项)
front(): 返回队列的第一个元素，也就是最新添加的那个
isAmpty: 检查队列是否为空，为空则返回true
clear: 移除队列中所有元素
size: 返回队列中元素个数。
print: 以字符串显示队列中所有内容


/*** 队列构造函数*//*** 队列构造函数*/function Queue() &#123;    /**    * 用数组来模拟队列    * @type &#123;Array&#125;    */    var items = [];    /**    * 将元素推入队列    * @param  &#123;Any&#125; ele 要推入队列的元素    */    this.enqueue = function(ele) &#123;        items.push ...</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2020/11/14/js/regex/" title="正则表达式大全">     <img class="post_bg" src="/img/default2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="正则表达式大全"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/11/14/js/regex/" title="正则表达式大全">正则表达式大全</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-11-14T08:10:34.247Z" title="发表于 2020-11-14 16:10:34">2020-11-14</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox article-meta__icon"></i><a class="article-meta__categories" href="/categories/web/">web</a></span></div><div class="content">测试工具
一、校验数字的表达式数字：^[0-9]*$n位的数字：^\\d{n}$至少n位的数字：^\\d{n,}$m-n位的数字：^\\d{m,n}$零和非零开头的数字：^(0|[1-9][0-9]*)$非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(\\.[0-9]{1,2})?$带1-2位小数的正数或负数：^(\\-)?\\d+(\\.\\d{1,2})$正数、负数、和小数：^(\\-|\\+)?\\d+(\\.\\d+)?$有两位小数的正实数：^[0-9]+(\\.[0-9]{2})?$有1~3位小数的正实数：^[0-9]+(\\.[0-9]{1,3})?$非零的正整数：^[1-9]\\d*$ 或 ^([1-9][0-9]*){1,3}$ 或 ^\\+?[1-9][0-9]*$非零的负整数：^\\-[1-9][]0-9"*$ 或 ^-[1-9]\\d*$非负整数：^\\d+$ 或 ^[1-9]\\d*|0$非正整数：^-[1-9]\\d*|0$ 或 ^((-\\d+)|(0+))$非负浮点数：^\\d+(\\.\\d+)?$ 或 ^[1-9]\\d*\\.\\d* ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2020/11/14/js/promise-polyfill/" title="Promise-Polyfill源码解析">     <img class="post_bg" src="/img/default3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Promise-Polyfill源码解析"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/11/14/js/promise-polyfill/" title="Promise-Polyfill源码解析">Promise-Polyfill源码解析</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-11-14T08:10:34.247Z" title="发表于 2020-11-14 16:10:34">2020-11-14</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox article-meta__icon"></i><a class="article-meta__categories" href="/categories/web/">web</a></span></div><div class="content">https://github.com/taylorhakes/promise-polyfill
我们平时都是以new Promise(params)的形式使用Promise的，说明Promise是一个构造函数，那我们就从构造函数为入口来分析Promise-polyfill源码。如下：
/*** @constructor* @param &#123;Function&#125; fn*/function Promise(fn) &#123;    if (!(this instanceof Promise))    throw new TypeError(&#x27;Promises must be constructed via new&#x27;);    if (typeof fn !== &#x27;function&#x27;) throw new TypeError(&#x27;not a function&#x27;);    /** @type &#123;!number&#125; */this._state = 0;/** @type &#123;!boolean&# ...</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2020/11/14/js/regex2/" title="正则表达式基本语法">     <img class="post_bg" src="/img/default2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="正则表达式基本语法"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/11/14/js/regex2/" title="正则表达式基本语法">正则表达式基本语法</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-11-14T08:10:34.247Z" title="发表于 2020-11-14 16:10:34">2020-11-14</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox article-meta__icon"></i><a class="article-meta__categories" href="/categories/web/">web</a></span></div><div class="content">&quot;^The&quot;：表示所有以&quot;The&quot;开始的字符串（&quot;There&quot;，&quot;The cat&quot;等）；&quot;of despair$&quot;：表示所以以&quot;of despair&quot;结尾的字符串；&quot;^abc$&quot;：表示开始和结尾都是&quot;abc&quot;的字符串——呵呵，只有&quot;abc&quot;自己了；&quot;notice&quot;：表示任何包含&quot;notice&quot;的字符串。&quot;ab*&quot;：表示一个字符串有一个a后面跟着零个或若干个b。（&quot;a&quot;, &quot;ab&quot;, &quot;abbb&quot;,……）；&quot;ab+&quot;：表示一个字符串有一个a后面跟着至少一个b或者更多；&quot;ab?&quot;：表示一个字符串有一个a后面跟着零个或者一个b；&quot;a?b+$&quot;：表示在字符串的末尾有零个或一个a跟着一个或几个b。必须要指定下限&quot;ab&#123;2& ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2020/11/14/js/link-list/" title="单向链表、循环链表、双向链表">     <img class="post_bg" src="/img/default3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="单向链表、循环链表、双向链表"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/11/14/js/link-list/" title="单向链表、循环链表、双向链表">单向链表、循环链表、双向链表</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-11-14T08:10:34.246Z" title="发表于 2020-11-14 16:10:34">2020-11-14</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox article-meta__icon"></i><a class="article-meta__categories" href="/categories/web/">web</a></span></div><div class="content">
链表是一种常见的数据结构，也属于线性表，但不会按线性的顺序来储存数据。而是在每一个节点中，储存了下一个节点的指针。

使用链表结构可以克服数组需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。单向链表链表中最简单的形式就是单向链表，链表中的节点都包含两个部分，第一部分储存着自身信息，第二部分则储存有指向下一节点的指针。最后一个节点则指向NULL，
单向链表需要有如下的方法:

append(element): 添加元素到链表尾部
insert(position,element): 向单向链表中某个位置插入元素
indexOf(element): 寻找某个元素在单向链表中的位置
remove(element): 移除给定的元素
removeAt(position): 移除单向链表中某个位置的元素
getHead(): 获取单向链表的头部
isAmpty(): 检查单向链表是否为空，为空则返回true
toString(): 将链表所有内容以字符串输出
size(): 返回单向链表长度


/**    * 单向链表构造函数    */functio ...</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2020/11/14/js/micro-task/" title="JS 引擎的执行机制">     <img class="post_bg" src="/img/default3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JS 引擎的执行机制"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/11/14/js/micro-task/" title="JS 引擎的执行机制">JS 引擎的执行机制</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-11-14T08:10:34.246Z" title="发表于 2020-11-14 16:10:34">2020-11-14</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox article-meta__icon"></i><a class="article-meta__categories" href="/categories/web/">web</a></span></div><div class="content">JSJS的执行机制是：
首先判断JS是同步还是异步，同步就进入主进程，异步就进入event table
异步任务在event table中注册函数，当满足触发条件后，被推入event queue
同步任务进入主线程后一直执行，直到主线程空闲时，才会去event queue中查看是否有可执行的异步任务，如果有就推入主进程中以上三步循环执行，这就是event loop。
而准确的划分方式是：
macro-task(宏任务)：包括整体代码script，setTimeout，setInterval，setImmediate
micro-task(微任务)：Promise，process.nextTick
setTimeout(function()&#123;    console.log(&#x27;定时器开始啦&#x27;)&#125;);new Promise(function(resolve)&#123;    console.log(&#x27;马上执行for循环啦&#x27;);    for(var i = 0; i &amp;lt; 10000; i++)&#123;       ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2020/11/14/js/mse/" title="MSE学习日志">     <img class="post_bg" src="/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MSE学习日志"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/11/14/js/mse/" title="MSE学习日志">MSE学习日志</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-11-14T08:10:34.246Z" title="发表于 2020-11-14 16:10:34">2020-11-14</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox article-meta__icon"></i><a class="article-meta__categories" href="/categories/Javascript/">Javascript</a></span></div><div class="content">MediaSource
使用 MediaSource 搭建流式播放器
FLV封装格式介绍及解析
FLV学习（二）FLV封装原理
flv格式详解+实例剖析
H.264标准（二）FLV封装格式详解
DASH简介及使用方法(FFmpeg, MP4Box)
构建简单的 MPEG-DASH 流媒体播放器
Dash.js
</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2020/11/14/js/new/" title="new 命令">     <img class="post_bg" src="/img/default3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="new 命令"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/11/14/js/new/" title="new 命令">new 命令</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-11-14T08:10:34.246Z" title="发表于 2020-11-14 16:10:34">2020-11-14</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox article-meta__icon"></i><a class="article-meta__categories" href="/categories/web/">web</a></span></div><div class="content">new命令的原理使用new命令时，它后面的函数调用就不是正常的调用，而是依次执行下面的步骤。


创建一个空对象，作为将要返回的对象实例



将这个空对象的原型，指向构造函数的prototype属性



将这个空对象赋值给函数内部的this关键字



开始执行构造函数内部的代码




注意：如果构造函数内部有return语句，而且return后面跟着一个对象，new命令会返回return语句指定的对象；否则，就会不管return语句，返回this对象。

function Car() &#123;    this.name = 11;     return &#123; age: 2 &#125;&#125;car1 = new Car()
这样是取不到car1里面的name属性，如果构造函数里面return 的为非对象，依然可以取到name
new命令简化的内部流程function _new(    /* 构造函数 */     constructor(/* 构造函数参数 */ param1) &#123;        // 将 arguments 对象转为数组       ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2020/11/14/js/num-string/" title="JavaScript 数据类型转换">     <img class="post_bg" src="/img/default3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JavaScript 数据类型转换"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/11/14/js/num-string/" title="JavaScript 数据类型转换">JavaScript 数据类型转换</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-11-14T08:10:34.246Z" title="发表于 2020-11-14 16:10:34">2020-11-14</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox article-meta__icon"></i><a class="article-meta__categories" href="/categories/web/">web</a></span></div><div class="content">
JS属于解释型语言，在执行过程中顺序执行，但是会分块先预编译然后才执行。因此在JS中存在一种变量提升的现象

强制转换强制转换主要指使用Number、String和Boolean三个构造函数，手动将各种类型的值，转换成数字、字符串或者布尔值。
// 数值：转换后还是原来的值Number(324) // 324//字符串：如果可以被解析为数值，则转换为相应的数值Number(&#x27;324&#x27;) // 324// 字符串：如果不可以被解析为数值，返回NaNNumber(&#x27;324abc&#x27;) // NaN// 空字符串转为0Number(&#x27;&#x27;) // 0// 布尔值：true 转成1，false 转成0Number(true) // 1Number(false) // 0// undefined：转成 NaNNumber(undefined) // NaN// null：转成0Number(null) // 0parseInt逐个解析字符，而Number函数整体转换字符串的类型。parseInt(&#x27;42 cats&#x27;)  ...</div></div></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/2/"><i class="fas fa-chevron-left fa-fw"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/4/"><i class="fas fa-chevron-right fa-fw"></i></a></div></nav></div><div class="aside_content" id="aside_content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><img class="avatar-img" src="/img/face.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">雪人</div><div class="author-info__description">雪人的笔记</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length_num">153</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length_num">40</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length_num">12</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/kwey"><i class="fab fa-github"></i><span>Follow Me</span></a></div></div><div class="sticky_layout"><div class="card-widget card-announcement"><div class="card-content"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/07/11/dm-render/render/" title="浏览器渲染原理"><img src="/img/default2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="浏览器渲染原理"/></a><div class="content"><a class="title" href="/2021/07/11/dm-render/render/" title="浏览器渲染原理">浏览器渲染原理</a><time datetime="2021-07-11T01:38:14.322Z" title="发表于 2021-07-11 09:38:14">2021-07-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/05/08/brower/fps/" title="WebRender如何摆脱jank"><img src="/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="WebRender如何摆脱jank"/></a><div class="content"><a class="title" href="/2021/05/08/brower/fps/" title="WebRender如何摆脱jank">WebRender如何摆脱jank</a><time datetime="2021-05-08T02:58:41.114Z" title="发表于 2021-05-08 10:58:41">2021-05-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/05/07/brower/gpu-acc/" title="GPU硬件加速"><img src="/img/default3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="GPU硬件加速"/></a><div class="content"><a class="title" href="/2021/05/07/brower/gpu-acc/" title="GPU硬件加速">GPU硬件加速</a><time datetime="2021-05-07T07:06:14.068Z" title="发表于 2021-05-07 15:06:14">2021-05-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/02/01/brower/lifecycle/" title="浏览器周期"><img src="/img/default3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="浏览器周期"/></a><div class="content"><a class="title" href="/2021/02/01/brower/lifecycle/" title="浏览器周期">浏览器周期</a><time datetime="2021-02-01T06:04:52.359Z" title="发表于 2021-02-01 14:04:52">2021-02-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/11/19/doc/mask/" title="CSS Masking Module Level 1"><img src="/img/hy.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CSS Masking Module Level 1"/></a><div class="content"><a class="title" href="/2020/11/19/doc/mask/" title="CSS Masking Module Level 1">CSS Masking Module Level 1</a><time datetime="2020-11-19T06:06:47.980Z" title="发表于 2020-11-19 14:06:47">2020-11-19</time></div></div></div></div></div><div class="card-widget" id="card-newest-comments"><div class="card-content"><div class="item-headline"><i class="fas fa-bolt"></i><span>最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="card-widget card-categories"><div class="card-content"><div class="item-headline"><i class="fas fa-folder-open"></i><span>分类</span></div><ul class="card-category-list" id="aside-cat-list">
            <li class="card-category-list-item "><a class="card-category-list-link" href="/categories/Databse/"><span class="card-category-list-name">Databse</span><span class="card-category-list-count">7</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/Javascript/"><span class="card-category-list-name">Javascript</span><span class="card-category-list-count">20</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/Linux/"><span class="card-category-list-name">Linux</span><span class="card-category-list-count">19</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/Node/"><span class="card-category-list-name">Node</span><span class="card-category-list-count">8</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/brower/"><span class="card-category-list-name">brower</span><span class="card-category-list-count">23</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/frame/"><span class="card-category-list-name">frame</span><span class="card-category-list-count">7</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/gpu/"><span class="card-category-list-name">gpu</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/network/"><span class="card-category-list-name">network</span><span class="card-category-list-count">1</span></a></li>
            <li class="card-category-list-item more is-center"><a class="card-category-list-link-more" href="/categories/">
                <span>查看更多</span><i class="fas fa-angle-right"></i></a></li>
            </ul></div></div><div class="card-widget card-tags"><div class="card-content"><div class="item-headline"><i class="fas fa-tags"></i><span>标签</span></div><div class="card-tag-cloud"><a href="/tags/CMD/" style="font-size: 1.1em; color: #999">CMD</a> <a href="/tags/CSS/" style="font-size: 1.1em; color: #999">CSS</a> <a href="/tags/Javascript/" style="font-size: 1.5em; color: #99a9bf">Javascript</a> <a href="/tags/Mongodb/" style="font-size: 1.19em; color: #999da1">Mongodb</a> <a href="/tags/brower/" style="font-size: 1.41em; color: #99a5b7">brower</a> <a href="/tags/centos/" style="font-size: 1.28em; color: #99a0aa">centos</a> <a href="/tags/cmd/" style="font-size: 1.32em; color: #99a2ae">cmd</a> <a href="/tags/cors/" style="font-size: 1.1em; color: #999">cors</a> <a href="/tags/css/" style="font-size: 1.28em; color: #99a0aa">css</a> <a href="/tags/django/" style="font-size: 1.19em; color: #999da1">django</a> <a href="/tags/err/" style="font-size: 1.1em; color: #999">err</a> <a href="/tags/es6/" style="font-size: 1.46em; color: #99a7bb">es6</a> <a href="/tags/git/" style="font-size: 1.1em; color: #999">git</a> <a href="/tags/github/" style="font-size: 1.14em; color: #999b9d">github</a> <a href="/tags/html/" style="font-size: 1.37em; color: #99a4b2">html</a> <a href="/tags/http/" style="font-size: 1.37em; color: #99a4b2">http</a> <a href="/tags/hy/" style="font-size: 1.1em; color: #999">hy</a> <a href="/tags/java/" style="font-size: 1.14em; color: #999b9d">java</a> <a href="/tags/javascript/" style="font-size: 1.1em; color: #999">javascript</a> <a href="/tags/jdk/" style="font-size: 1.1em; color: #999">jdk</a> <a href="/tags/jwt/" style="font-size: 1.1em; color: #999">jwt</a> <a href="/tags/lifecycle/" style="font-size: 1.1em; color: #999">lifecycle</a> <a href="/tags/mobile/" style="font-size: 1.1em; color: #999">mobile</a> <a href="/tags/model/" style="font-size: 1.23em; color: #999ea6">model</a> <a href="/tags/mse/" style="font-size: 1.1em; color: #999">mse</a> <a href="/tags/mysql/" style="font-size: 1.23em; color: #999ea6">mysql</a> <a href="/tags/network/" style="font-size: 1.1em; color: #999">network</a> <a href="/tags/nginx/" style="font-size: 1.28em; color: #99a0aa">nginx</a> <a href="/tags/node/" style="font-size: 1.1em; color: #999">node</a> <a href="/tags/npm/" style="font-size: 1.14em; color: #999b9d">npm</a> <a href="/tags/nuxt/" style="font-size: 1.1em; color: #999">nuxt</a> <a href="/tags/proxy/" style="font-size: 1.1em; color: #999">proxy</a> <a href="/tags/schedule/" style="font-size: 1.1em; color: #999">schedule</a> <a href="/tags/tcp/" style="font-size: 1.1em; color: #999">tcp</a> <a href="/tags/typescript/" style="font-size: 1.14em; color: #999b9d">typescript</a> <a href="/tags/video/" style="font-size: 1.19em; color: #999da1">video</a> <a href="/tags/vue/" style="font-size: 1.14em; color: #999b9d">vue</a> <a href="/tags/webpack/" style="font-size: 1.28em; color: #99a0aa">webpack</a> <a href="/tags/ws/" style="font-size: 1.14em; color: #999b9d">ws</a> <a href="/tags/xhr/" style="font-size: 1.1em; color: #999">xhr</a></div></div></div><div class="card-widget card-archives"><div class="card-content"><div class="item-headline"><i class="fas fa-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2021/07/"><span class="card-archive-list-date">七月 2021</span><span class="card-archive-list-count">1</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2021/05/"><span class="card-archive-list-date">五月 2021</span><span class="card-archive-list-count">2</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2021/02/"><span class="card-archive-list-date">二月 2021</span><span class="card-archive-list-count">1</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2020/11/"><span class="card-archive-list-date">十一月 2020</span><span class="card-archive-list-count">149</span></a></li></ul></div></div><div class="card-widget card-webinfo"><div class="card-content"><div class="item-headline"><i class="fas fa-chart-line"></i><span>网站资讯</span></div><div class="webinfo"><div class="webinfo-item"><div class="item-name">文章数目 :</div><div class="item-count">153</div></div><div class="webinfo-item"><div class="item-name">本站总字数 :</div><div class="item-count">345.2k</div></div><div class="webinfo-item"><div class="item-name">最后更新时间 :</div><div class="item-count" id="last-push-date" data-lastPushDate="2021-07-11T12:14:52.107Z"></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By 雪人</div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.spacingElementById('content-inner')
  else {
    $.getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js', () => {
      pangu.spacingElementById('content-inner')
    })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguFn)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div></div></body></html>